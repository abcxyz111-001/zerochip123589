<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Công Cụ Mô Phỏng Giải Thuật</title>
    <style>
        :root {
            /* MODIFIED: New Gentle Color Palette */
            --bg-color: #fce4ec; /* Light Pink */
            --container-bg-color: #f8bbd0; /* Darker Pink */
            --text-color: #424242; /* Dark Gray for readability */
            
            --button-color: #81d4fa; /* Sky Blue */
            --button-hover-color: #4fc3f7; /* Darker Sky Blue */
            --button-gradient-start: #b3e5fc; /* Lighter Sky Blue */
            --button-border-color: #29b6f6; /* Border Sky Blue */

            --button-action-color: #ff80ab; /* Bright Pink */
            --button-action-hover-color: #f50057; /* Darker Bright Pink */
            --button-action-gradient-start: #ffb2dd; /* Lighter Bright Pink */
            --button-action-border-color: #f50057;

            --shadow-color: rgba(0, 0, 0, 0.1);

            /* Pathfinding Colors */
            --node-border-color: rgba(165, 214, 167, 0.5);
            --node-start-color: #a5d6a7; /* Gentle Green */
            --node-finish-color: #ff80ab; /* Action Pink */
            --node-wall-color: #e0e0e0; /* Soft Gray */
            --node-visited-color: rgba(129, 212, 250, 0.75); /* Sky Blue */
            --node-visited-b-color: rgba(255, 245, 157, 0.75); /* Gentle Yellow */
            --node-path-color: #fff59d;

            /* Sorting Colors */
            --bar-default-color: #81d4fa; /* Sky Blue */
            --bar-compare-color: #fff59d; /* Gentle Yellow */
            --bar-swap-color: #ff80ab; /* Action Pink */
            --bar-sorted-color: #a5d6a7; /* Gentle Green */
            --bar-pivot-color: #ce93d8; /* Gentle Purple */
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px 0;
        }
        
        h1, h2 { margin: 0 0 10px 0; }
        p { margin: 5px 0 0 0; color: #757575; }

        .app-container {
            width: 98%;
            max-width: 1400px;
            padding: 20px;
            position: relative;
        }
        
        #main-menu { text-align: center; }
        #main-menu h1 { font-size: 2.5em; }
        .menu-buttons { display: flex; flex-wrap: wrap; justify-content: center; gap: 30px; margin-top: 30px; }
        .menu-buttons button { font-size: 1.2em; padding: 20px 40px; }

        .visualizer-container {
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
        }
        .visualizer-container.visible {
            display: block;
            opacity: 1;
            animation: fadeIn 0.4s ease-in-out;
        }
        
        .controls {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .control-group { 
            display: flex; 
            flex-direction: row; 
            align-items: center; 
            gap: 10px; 
        }
        
        #algo-info { text-align: center; margin-bottom: 15px; font-style: italic; color: #757575; min-height: 20px; }

        /* --- Unified Button and Custom Select Styles --- */
        button, .custom-select-trigger {
            padding: 10px 18px;
            border-radius: 8px;
            border: 1px solid var(--button-border-color);
            background-image: linear-gradient(to bottom, var(--button-gradient-start), var(--button-color));
            color: white;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 0 1px 1px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px var(--shadow-color), inset 0 1px 0 rgba(255,255,255,0.2);
            position: relative;
            vertical-align: middle;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and IE 11 */
            user-select: none; /* Standard syntax */
        }

        button {
            display: inline-flex;
            align-items: center;
        }
        
        .custom-select-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-width: 180px;
        }

        button:hover, .custom-select-trigger:hover {
            background-image: linear-gradient(to bottom, var(--button-gradient-start), var(--button-hover-color));
            box-shadow: 0 6px 8px var(--shadow-color), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        button:active, .custom-select-trigger:active {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }
        button:active {
            transform: translateY(2px);
        }

        .visualize-btn {
            background-image: linear-gradient(to bottom, var(--button-action-gradient-start), var(--button-action-color));
            border-color: var(--button-action-border-color);
        }
        .visualize-btn:hover {
            background-image: linear-gradient(to bottom, var(--button-action-gradient-start), var(--button-action-hover-color));
        }
        
        button:disabled, .custom-select-trigger.disabled {
            background-image: none;
            background-color: #e0e0e0;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #bdbdbd;
        }
        
        /* --- Custom Select Dropdown --- */
        .custom-select-container {
            position: relative;
            display: inline-block;
            vertical-align: middle;
        }

        .custom-options {
            position: absolute;
            top: calc(100% + 5px);
            left: 0;
            right: 0;
            z-index: 20;
            background-color: white;
            border: 1px solid var(--button-border-color);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            padding: 5px; /* Added padding for options */
            
            opacity: 0;
            visibility: hidden;
            transform-origin: top center;
            transform: translateY(-10px) scale(0.98);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
        }

        .custom-options.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .custom-option {
            padding: 12px 18px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            color: var(--text-color);
            border-radius: 6px; /* MODIFIED: Rounded corners for each option */
        }

        .custom-option:hover {
            background-color: var(--button-hover-color);
            color: white;
            transform: translateX(5px);
        }

        .custom-option.selected {
            background-color: var(--button-color);
            color: white;
        }
        
        /* --- Language Button --- */
        #language-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            padding: 0;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }

        /* --- Language Modal --- */
        #language-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.3); backdrop-filter: blur(5px);
            z-index: 1000; display: flex; justify-content: center; align-items: center;
            opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
        }
        #language-overlay.visible { opacity: 1; visibility: visible; }
        .language-modal {
            background-color: white; padding: 30px;
            border-radius: 10px; box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            text-align: center; transform: scale(0.9); transition: transform 0.3s;
        }
        #language-overlay.visible .language-modal { transform: scale(1); }
        .language-modal h2 { margin-top: 0; }
        .language-modal .lang-options { display: flex; gap: 20px; margin-top: 20px; }

        /* --- Custom Toggle Switch --- */
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #bdbdbd; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--button-color); }
        input:checked + .slider:before { transform: translateX(22px); }

        /* --- Pathfinding Specific Styles --- */
        .pathfinding-content-wrapper {
             max-width: 1052px; /* 42 nodes * 25px + 2px border */
             margin: 0 auto;
        }

        #grid-container { display: grid; border: 1px solid var(--node-start-color); touch-action: none; background-color: white; }
        .node { 
            width: 25px; height: 25px; 
            outline: 1px solid var(--node-border-color);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .node-info { font-size: 9px; color: black; font-weight: bold; pointer-events: none; display: none; }
        #grid-container.show-numbers .node-info { display: block; }
        .node-start { background-color: var(--node-start-color); }
        .node-finish { background-color: var(--node-finish-color); }
        .node-wall { background-color: var(--node-wall-color); animation: growWall 0.3s; }
        .node-visited { animation: visitedAnimation 1.5s forwards; }
        .node-visited-b { animation: visitedAnimationB 1.5s forwards; }
        .node-shortest-path { animation: pathAnimation 1.5s forwards; }

        /* --- Sorting Specific Styles --- */
        #sorting-visualization-container {
            display: flex; justify-content: center; align-items: flex-end; min-height: 450px;
            background-color: white; padding: 10px; border-radius: 8px; overflow: hidden;
        }
        .bar-container { display: flex; flex-direction: column; align-items: center; margin: 0 1px; }
        .bar { display: inline-block; background-color: var(--bar-default-color); transition: height 0.2s, background-color 0.2s; }
        .bar-label { font-size: 10px; color: var(--text-color); margin-top: 5px; }

        /* --- Animations --- */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes visitedAnimation { 0%{transform:scale(.3); background-color:#4dd0e1; border-radius:100%} 50%{background-color:var(--node-visited-color)} 75%{transform:scale(1.2)} 100%{transform:scale(1); background-color:var(--node-visited-color)} }
        @keyframes visitedAnimationB { 0%{transform:scale(.3); background-color:#4dd0e1; border-radius:100%} 50%{background-color:var(--node-visited-b-color)} 75%{transform:scale(1.2)} 100%{transform:scale(1); background-color:var(--node-visited-b-color)} }
        @keyframes pathAnimation { 0%{transform:scale(.6); background-color:var(--node-finish-color)} 100%{transform:scale(1); background-color:var(--node-path-color)} }
        @keyframes growWall { 0%{transform:scale(.7)} 100%{transform:scale(1)} }
    </style>
</head>
<body>

    <div class="app-container">
        <!-- ===== LANGUAGE BUTTON ===== -->
        <button id="language-btn">🌎</button>

        <!-- ===== LANGUAGE MODAL ===== -->
        <div id="language-overlay">
            <div class="language-modal">
                <h2 data-lang-key="select_language">Chọn Ngôn Ngữ</h2>
                <div class="lang-options">
                    <button id="lang-vi">Tiếng Việt</button>
                    <button id="lang-en">English</button>
                </div>
            </div>
        </div>

        <!-- ===== MAIN MENU ===== -->
        <div id="main-menu">
            <h1 data-lang-key="main_title">Công Cụ Mô Phỏng Giải Thuật</h1>
            <p data-lang-key="main_subtitle">Chọn một danh mục để bắt đầu</p>
            <div class="menu-buttons">
                <button id="show-sorting-btn" data-lang-key="sorting_algos">Thuật toán Sắp xếp</button>
                <button id="show-pathfinding-btn" data-lang-key="pathfinding_algos">Thuật toán Tìm đường</button>
            </div>
        </div>

        <!-- ===== PATHFINDING VISUALIZER ===== -->
        <div id="pathfinding-visualizer" class="visualizer-container">
            <div class="pathfinding-content-wrapper">
                <header style="text-align:center; margin-bottom:15px;">
                    <h1 data-lang-key="path_title">Trình Mô Phỏng Giải Thuật Tìm Đường</h1>
                    <p data-lang-key="path_subtitle">Nhấn giữ chuột để vẽ tường. Kéo thả nút Xanh (Start) và Đỏ (Finish).</p>
                </header>
                <nav class="controls">
                    <button class="back-to-menu-btn" data-lang-key="back_to_menu">&larr; Quay lại Menu</button>
                    <div class="control-group">
                        <label for="pf-algorithm-select" data-lang-key="select_algo">Chọn Giải Thuật</label>
                        <div class="select-wrapper">
                            <select id="pf-algorithm-select">
                                <option value="astar">A* Search</option>
                                <option value="dijkstra">Dijkstra</option>
                                <option value="bfs">Breadth-First (BFS)</option>
                                <option value="dfs">Depth-First (DFS)</option>
                                <option value="greedy">Greedy Best-first</option>
                                <option value="bidirectional">Bidirectional Search</option>
                            </select>
                        </div>
                    </div>
                    <button class="visualize-btn" id="pf-visualize-btn" data-lang-key="visualize">Mô phỏng!</button>
                    <button id="pf-clear-walls-btn" data-lang-key="clear_walls">Xóa Tường</button>
                    <button id="pf-clear-board-btn" data-lang-key="clear_board">Làm Mới Bảng</button>
                    <div class="control-group">
                        <label for="pf-show-numbers-toggle" data-lang-key="show_numbers">Hiện Số</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="pf-show-numbers-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </nav>
                <div id="algo-info"></div>
                <main id="grid-container"></main>
            </div>
        </div>

        <!-- ===== SORTING VISUALIZER ===== -->
        <div id="sorting-visualizer" class="visualizer-container">
            <header style="text-align:center; margin-bottom:15px;">
                 <h1 data-lang-key="sort_title">Trình Mô Phỏng Giải Thuật Sắp Xếp</h1>
            </header>
            <nav class="controls">
                <button class="back-to-menu-btn" data-lang-key="back_to_menu_2">&larr; Quay lại Menu</button>
                <button id="generate-array-btn" data-lang-key="new_array">Tạo Mảng Mới</button>
                <div class="control-group">
                    <label for="algorithm-select" data-lang-key="select_algo_2">Chọn Giải Thuật</label>
                    <div class="select-wrapper">
                        <select id="algorithm-select">
                            <option value="bubbleSort">Bubble Sort</option>
                            <option value="selectionSort">Selection Sort</option>
                            <option value="insertionSort">Insertion Sort</option>
                            <option value="mergeSort">Merge Sort</option>
                            <option value="quickSort">Quick Sort</option>
                            <option value="heapSort">Heap Sort</option>
                            <option value="shellSort">Shell Sort</option>
                            <option value="radixSort">Radix Sort</option>
                        </select>
                    </div>
                </div>
                <div class="control-group">
                    <label for="array-size-slider" data-lang-key="size">Số Lượng: <span id="array-size-label">50</span></label>
                    <input type="range" id="array-size-slider" min="10" max="150" value="50">
                </div>
                <div class="control-group">
                    <label for="speed-slider" data-lang-key="speed">Tốc Độ</label>
                    <input type="range" id="speed-slider" min="5" max="200" value="50">
                </div>
                <button class="visualize-btn" id="sort-btn" data-lang-key="sort">Sắp Xếp</button>
            </nav>
            <main id="sorting-visualization-container"></main>
        </div>
    </div>

<script>
// =============================
// ===== TRANSLATION SCRIPT =====
// =============================
const translations = {
    en: {
        main_title: "Algorithm Visualization Hub",
        main_subtitle: "Select a category to begin",
        sorting_algos: "Sorting Algorithms",
        pathfinding_algos: "Pathfinding Algorithms",
        path_title: "Pathfinding Algorithm Visualizer",
        path_subtitle: "Click and drag to draw walls. Drag and drop the Green (Start) and Red (Finish) nodes.",
        back_to_menu: "\u2190 Back to Menu",
        back_to_menu_2: "\u2190 Back to Menu",
        select_algo: "Select Algorithm",
        select_algo_2: "Select Algorithm",
        visualize: "Visualize!",
        clear_walls: "Clear Walls",
        clear_board: "Clear Board",
        show_numbers: "Show Numbers",
        sort_title: "Sorting Algorithm Visualizer",
        new_array: "New Array",
        size: "Size:",
        speed: "Speed",
        sort: "Sort",
        select_language: "Select Language",
        algo_info_dijkstra: 'Dijkstra: Guarantees the shortest path. Explores in all directions.',
        algo_info_astar: 'A* Search: Guarantees the shortest path. Prioritizes moving towards the target.',
        algo_info_greedy: 'Greedy Best-first: Does not guarantee shortest path. Very fast, always moves towards the target.',
        algo_info_bfs: 'Breadth-First Search: Guarantees the shortest path. Explores layer by layer.',
        algo_info_dfs: 'Depth-First Search: Does not guarantee shortest path. Explores deep into one branch.',
        algo_info_bidirectional: 'Bidirectional Search (BFS): Searches from both ends. Very efficient.'
    },
    vi: {
        main_title: "Công Cụ Mô Phỏng Giải Thuật",
        main_subtitle: "Chọn một danh mục để bắt đầu",
        sorting_algos: "Thuật toán Sắp xếp",
        pathfinding_algos: "Thuật toán Tìm đường",
        path_title: "Trình Mô Phỏng Giải Thuật Tìm Đường",
        path_subtitle: "Nhấn giữ chuột để vẽ tường. Kéo thả nút Xanh (Start) và Đỏ (Finish).",
        back_to_menu: "\u2190 Quay lại Menu",
        back_to_menu_2: "\u2190 Quay lại Menu",
        select_algo: "Chọn Giải Thuật",
        select_algo_2: "Chọn Giải Thuật",
        visualize: "Mô phỏng!",
        clear_walls: "Xóa Tường",
        clear_board: "Làm Mới Bảng",
        show_numbers: "Hiện Số",
        sort_title: "Trình Mô Phỏng Giải Thuật Sắp Xếp",
        new_array: "Tạo Mảng Mới",
        size: "Số Lượng:",
        speed: "Tốc Độ",
        sort: "Sắp Xếp",
        select_language: "Chọn Ngôn Ngữ",
        algo_info_dijkstra: 'Dijkstra: Đảm bảo đường đi ngắn nhất. Khám phá mọi hướng.',
        algo_info_astar: 'A* Search: Đảm bảo đường đi ngắn nhất. Ưu tiên hướng về đích.',
        algo_info_greedy: 'Greedy Best-first: Không đảm bảo ngắn nhất. Rất nhanh, luôn đi về phía đích.',
        algo_info_bfs: 'Breadth-First Search: Đảm bảo đường đi ngắn nhất. Khám phá theo từng lớp.',
        algo_info_dfs: 'Depth-First Search: Không đảm bảo ngắn nhất. Khám phá sâu vào một nhánh.',
        algo_info_bidirectional: 'Bidirectional Search (BFS): Tìm kiếm từ 2 phía. Rất hiệu quả.'
    }
};

const languageBtn = document.getElementById('language-btn');
const languageOverlay = document.getElementById('language-overlay');
const langViBtn = document.getElementById('lang-vi');
const langEnBtn = document.getElementById('lang-en');
let currentLang = 'vi';

function changeLanguage(lang) {
    currentLang = lang;
    document.documentElement.lang = lang;
    document.querySelectorAll('[data-lang-key]').forEach(el => {
        const key = el.dataset.langKey;
        if (key.startsWith('size')) {
             const sizeLabel = document.getElementById('array-size-label');
             el.innerHTML = `${translations[lang][key]} <span id="array-size-label">${sizeLabel.innerText}</span>`;
        } else {
             el.textContent = translations[lang][key];
        }
    });
    const pfAlgoSelect = document.getElementById('pf-algorithm-select');
    if (pfAlgoSelect) {
        const currentAlgo = pfAlgoSelect.value;
        const algoInfoKey = `algo_info_${currentAlgo}`;
        document.getElementById('algo-info').textContent = translations[lang][algoInfoKey] || '';
    }
    
    languageOverlay.classList.remove('visible');
}

languageBtn.addEventListener('click', () => languageOverlay.classList.add('visible'));
languageOverlay.addEventListener('click', (e) => {
    if (e.target === languageOverlay) {
        languageOverlay.classList.remove('visible');
    }
});
langViBtn.addEventListener('click', () => changeLanguage('vi'));
langEnBtn.addEventListener('click', () => changeLanguage('en'));


// Global navigation logic
const mainMenu = document.getElementById('main-menu');
const sortingVisualizer = document.getElementById('sorting-visualizer');
const pathfindingVisualizer = document.getElementById('pathfinding-visualizer');
const showSortingBtn = document.getElementById('show-sorting-btn');
const showPathfindingBtn = document.getElementById('show-pathfinding-btn');
const backToMenuBtns = document.querySelectorAll('.back-to-menu-btn');

showSortingBtn.addEventListener('click', () => {
    mainMenu.style.display = 'none';
    sortingVisualizer.classList.add('visible');
    window.dispatchEvent(new CustomEvent('sorting-load'));
});

showPathfindingBtn.addEventListener('click', () => {
    mainMenu.style.display = 'none';
    pathfindingVisualizer.classList.add('visible');
    window.dispatchEvent(new CustomEvent('pathfinding-load'));
});

backToMenuBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        window.location.reload(); 
    });
});


// ===================================
// ===== CUSTOM SELECT SCRIPT =====
// ===================================
function initializeCustomSelects() {
    document.querySelectorAll('.select-wrapper').forEach(wrapper => {
        const originalSelect = wrapper.querySelector('select');
        if (wrapper.querySelector('.custom-select-container')) return; // Already initialized

        const customSelectContainer = document.createElement('div');
        customSelectContainer.className = 'custom-select-container';

        const customSelectTrigger = document.createElement('div');
        customSelectTrigger.className = 'custom-select-trigger';
        
        const selectedOptionText = document.createElement('span');
        selectedOptionText.textContent = originalSelect.options[originalSelect.selectedIndex].text;
        
        const arrow = document.createElement('span');
        arrow.className = 'arrow';
        arrow.innerHTML = '▼';

        customSelectTrigger.appendChild(selectedOptionText);
        customSelectTrigger.appendChild(arrow);
        
        const customOptions = document.createElement('div');
        customOptions.className = 'custom-options';

        Array.from(originalSelect.options).forEach(optionElement => {
            const customOption = document.createElement('div');
            customOption.className = 'custom-option';
            customOption.textContent = optionElement.text;
            customOption.dataset.value = optionElement.value;

            if (optionElement.selected) {
                customOption.classList.add('selected');
            }

            customOption.addEventListener('click', () => {
                if (customSelectTrigger.classList.contains('disabled')) return;
                const prevSelected = customOptions.querySelector('.custom-option.selected');
                if (prevSelected) prevSelected.classList.remove('selected');
                
                customOption.classList.add('selected');
                selectedOptionText.textContent = customOption.textContent;
                originalSelect.value = customOption.dataset.value;
                originalSelect.dispatchEvent(new Event('change'));
                customOptions.classList.remove('open');
            });
            customOptions.appendChild(customOption);
        });

        customSelectTrigger.addEventListener('click', (e) => {
            if (customSelectTrigger.classList.contains('disabled')) return;
            e.stopPropagation();
            document.querySelectorAll('.custom-options.open').forEach(openSelect => {
                if (openSelect !== customOptions) openSelect.classList.remove('open');
            });
            customOptions.classList.toggle('open');
        });

        customSelectContainer.appendChild(customSelectTrigger);
        customSelectContainer.appendChild(customOptions);

        wrapper.appendChild(customSelectContainer);
        originalSelect.style.display = 'none';
    });
}

window.addEventListener('click', () => {
    document.querySelectorAll('.custom-options.open').forEach(openSelect => {
        openSelect.classList.remove('open');
    });
});

document.addEventListener('DOMContentLoaded', initializeCustomSelects);


// ===================================
// ===== PATHFINDING SCRIPT PART =====
// ===================================
(function() {
    const GRID_WIDTH = 42, GRID_HEIGHT = 20;
    let START_NODE_ROW = 10, START_NODE_COL = 8;
    let FINISH_NODE_ROW = 10, FINISH_NODE_COL = 34;

    const gridContainer = document.getElementById('grid-container');
    const visualizeBtn = document.getElementById('pf-visualize-btn');
    const clearWallsBtn = document.getElementById('pf-clear-walls-btn');
    const clearBoardBtn = document.getElementById('pf-clear-board-btn');
    const algorithmSelect = document.getElementById('pf-algorithm-select');
    const algoInfoDiv = document.getElementById('algo-info');
    const showNumbersToggle = document.getElementById('pf-show-numbers-toggle');
    
    let grid = [], mouseIsPressed = false, isRunning = false, movingNode = null;
    let lastNodeProcessed = null;

    class Node {
        constructor(row, col) {
            this.row = row; this.col = col; this.isStart = false; this.isFinish = false;
            this.distance = Infinity; this.isVisited = false; this.isWall = false;
            this.previousNode = null; this.gScore = Infinity; this.fScore = Infinity;
            this.hScore = 0; this.isVisitedB = false; this.previousNodeB = null;
            this.element = document.createElement('div');
            this.element.className = 'node';
            this.element.id = `node-${row}-${col}`;
            this.infoElement = document.createElement('span');
            this.infoElement.className = 'node-info';
            this.element.appendChild(this.infoElement);
        }
        reset() {
            this.isVisited = false; this.distance = Infinity; this.previousNode = null;
            this.gScore = Infinity; this.fScore = Infinity; this.hScore = 0;
            this.isVisitedB = false; this.previousNodeB = null;
            this.element.classList.remove('node-visited', 'node-shortest-path', 'node-visited-b');
            this.infoElement.textContent = '';
        }
        toggleWall() {
            if (this.isStart || this.isFinish) return;
            this.isWall = !this.isWall;
            this.element.classList.toggle('node-wall', this.isWall);
        }
    }

    function initializeGrid() {
        gridContainer.innerHTML = ''; grid = [];
        gridContainer.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, 25px)`;
        for (let r = 0; r < GRID_HEIGHT; r++) {
            const row = [];
            for (let c = 0; c < GRID_WIDTH; c++) {
                const node = new Node(r, c);
                row.push(node);
                gridContainer.appendChild(node.element);
            }
            grid.push(row);
        }
        setSpecialNode('start', START_NODE_ROW, START_NODE_COL);
        setSpecialNode('finish', FINISH_NODE_ROW, FINISH_NODE_COL);
    }

    function handleInteractionStart(e) {
        if (isRunning) return;
        const node = getNodeFromEvent(e);
        if (!node) return;
        if (node.isStart) movingNode = 'start';
        else if (node.isFinish) movingNode = 'finish';
        else node.toggleWall();
        mouseIsPressed = true;
        lastNodeProcessed = node;
    }
    
    function handleInteractionMove(e) {
        if (!mouseIsPressed || isRunning) return;
        e.preventDefault();
        const node = getNodeFromEvent(e);
        if (!node || node === lastNodeProcessed) return;
        if (movingNode) moveSpecialNode(node);
        else node.toggleWall();
        lastNodeProcessed = node;
    }

    function handleInteractionEnd() {
        mouseIsPressed = false; movingNode = null; lastNodeProcessed = null;
    }
    
    function getNodeFromEvent(e) {
        const coords = e.touches ? e.touches[0] : e;
        const targetElement = document.elementFromPoint(coords.clientX, coords.clientY);
        if (!targetElement || !targetElement.id.startsWith('node-')) return null;
        const [_, row, col] = targetElement.id.split('-').map(Number);
        return (grid[row] && grid[row][col]) ? grid[row][col] : null;
    }
    
    function updateNodeText(node) {
        const algo = algorithmSelect.value;
        let text = '';
        switch(algo) {
            case 'dijkstra': if (node.distance !== Infinity) text = node.distance; break;
            case 'astar': if (node.fScore !== Infinity) text = node.fScore; break;
            case 'greedy': if (node.distance !== Infinity) text = node.distance; break;
        }
        node.infoElement.textContent = text;
    }

    function moveSpecialNode(newNode) {
        const isStart = movingNode === 'start';
        const oldRow = isStart ? START_NODE_ROW : FINISH_NODE_ROW, oldCol = isStart ? START_NODE_COL : FINISH_NODE_COL;
        if (newNode.row === oldRow && newNode.col === oldCol || newNode.isWall || (isStart && newNode.isFinish) || (!isStart && newNode.isStart)) return;
        clearSpecialNode(movingNode, oldRow, oldCol);
        if (isStart) { START_NODE_ROW = newNode.row; START_NODE_COL = newNode.col; } 
        else { FINISH_NODE_ROW = newNode.row; FINISH_NODE_COL = newNode.col; }
        setSpecialNode(movingNode, newNode.row, newNode.col);
    }
    
    function setSpecialNode(type, r, c) { grid[r][c][`is${type.charAt(0).toUpperCase() + type.slice(1)}`] = true; grid[r][c].element.classList.add(`node-${type}`); }
    function clearSpecialNode(type, r, c) { grid[r][c][`is${type.charAt(0).toUpperCase() + type.slice(1)}`] = false; grid[r][c].element.classList.remove(`node-${type}`); }
    function clearPath() { for (let row of grid) for (let node of row) node.reset(); }
    function clearWalls() {
        for (let row of grid) for (let node of row) {
            node.reset();
            if (!node.isStart && !node.isFinish) {
                node.isWall = false;
                node.element.classList.remove('node-wall');
            }
        }
    }
    function setAlgoInfo() {
        const algoKey = algorithmSelect.value;
        const infoKey = `algo_info_${algoKey}`;
        algoInfoDiv.textContent = translations[currentLang][infoKey] || '';
    }

    visualizeBtn.addEventListener('click', () => { if (!isRunning) { clearPath(); visualizeAlgorithm(); } });
    clearWallsBtn.addEventListener('click', () => !isRunning && clearWalls());
    clearBoardBtn.addEventListener('click', () => !isRunning && initializeGrid());
    algorithmSelect.addEventListener('change', setAlgoInfo);
    showNumbersToggle.addEventListener('change', () => { gridContainer.classList.toggle('show-numbers', showNumbersToggle.checked); });
    function setControls(enabled) {
        visualizeBtn.disabled = !enabled; clearWallsBtn.disabled = !enabled;
        clearBoardBtn.disabled = !enabled; 
        document.querySelectorAll('.custom-select-trigger').forEach(s => {
            enabled ? s.classList.remove('disabled') : s.classList.add('disabled');
        });
    }
    
    gridContainer.addEventListener('mousedown', handleInteractionStart);
    gridContainer.addEventListener('touchstart', handleInteractionStart, { passive: false });
    gridContainer.addEventListener('mousemove', handleInteractionMove);
    gridContainer.addEventListener('touchmove', handleInteractionMove, { passive: false });
    window.addEventListener('mouseup', handleInteractionEnd);
    window.addEventListener('touchend', handleInteractionEnd);

    async function visualizeAlgorithm() {
        isRunning = true; setControls(false);
        const startNode = grid[START_NODE_ROW][START_NODE_COL], finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL], algo = algorithmSelect.value;
        let visited = [], path = [];
        switch (algo) {
            case 'dijkstra': visited = dijkstra(startNode, finishNode); break;
            case 'astar': visited = aStar(startNode, finishNode); break;
            case 'greedy': visited = greedyBFS(startNode, finishNode); break;
            case 'bfs': visited = bfs(startNode, finishNode); break;
            case 'dfs': visited = dfs(startNode, finishNode); break;
            case 'bidirectional': await visualizeBidirectional(startNode, finishNode); isRunning = false; setControls(true); return;
        }
        path = getPath(finishNode);
        await animate(visited, path);
        isRunning = false; setControls(true);
    }
    
    async function animate(visited, path, isBi = false, pathB = []) {
        for (let i = 0; i < visited.length; i++) {
            await new Promise(r => setTimeout(r, 10));
            const currentNode = isBi ? visited[i].node : visited[i];
            if (isBi) {
                if (visited[i].from === 'start') currentNode.element.classList.add('node-visited');
                else currentNode.element.classList.add('node-visited-b');
            } else if (!currentNode.isStart && !currentNode.isFinish) currentNode.element.classList.add('node-visited');
        }
        await animatePath(path);
        if (isBi) await animatePath(pathB);
    }

    async function animatePath(path) {
        for (let i = 0; i < path.length; i++) {
            await new Promise(r => setTimeout(r, 40));
            const node = path[i];
            if (!node.isStart && !node.isFinish) {
                node.element.classList.remove('node-visited', 'node-visited-b');
                node.element.classList.add('node-shortest-path');
            }
        }
    }
    
    function getPath(finishNode) {
        const path = []; let curr = finishNode;
        if (curr.previousNode === null && !curr.isStart) return [];
        while (curr !== null) { path.unshift(curr); curr = curr.previousNode; }
        return path;
    }
    
    function getNeighbors(node) {
        const neighbors = [], { col, row } = node;
        if (row > 0) neighbors.push(grid[row - 1][col]);
        if (row < GRID_HEIGHT - 1) neighbors.push(grid[row + 1][col]);
        if (col > 0) neighbors.push(grid[row][col - 1]);
        if (col < GRID_WIDTH - 1) neighbors.push(grid[row][col + 1]);
        return neighbors.filter(n => !n.isWall);
    }

    function heuristic(a, b) { return Math.abs(a.row - b.row) + Math.abs(a.col - b.col); }
    function getAllNodes() { return grid.flat(); }
    
    function dijkstra(start, finish) {
        const visited = []; start.distance = 0; updateNodeText(start); const unvisited = getAllNodes();
        while (unvisited.length) {
            unvisited.sort((a, b) => a.distance - b.distance);
            const closest = unvisited.shift();
            if (closest.isWall) continue;
            if (closest.distance === Infinity) return visited;
            closest.isVisited = true; visited.push(closest);
            if (closest === finish) return visited;
            const neighbors = getNeighbors(closest);
            for (const neighbor of neighbors) if (!neighbor.isVisited) {
                const newDist = closest.distance + 1;
                if(newDist < neighbor.distance) {
                    neighbor.distance = newDist; neighbor.previousNode = closest;
                    updateNodeText(neighbor);
                }
            }
        }
        return visited;
    }

    function aStar(start, finish) {
        const visited = [], openSet = [start];
        start.gScore = 0; start.hScore = heuristic(start, finish); start.fScore = start.hScore;
        updateNodeText(start);
        while (openSet.length) {
            openSet.sort((a, b) => a.fScore - b.fScore);
            const current = openSet.shift();
            if (current === finish) return visited;
            current.isVisited = true; visited.push(current);
            const neighbors = getNeighbors(current);
            for (const neighbor of neighbors) {
                if (neighbor.isVisited) continue;
                const tentG = current.gScore + 1;
                if (tentG < neighbor.gScore) {
                    neighbor.previousNode = current; neighbor.gScore = tentG;
                    neighbor.hScore = heuristic(neighbor, finish);
                    neighbor.fScore = neighbor.gScore + neighbor.hScore;
                    updateNodeText(neighbor);
                    if (!openSet.includes(neighbor)) openSet.push(neighbor);
                }
            }
        }
        return visited;
    }

    function greedyBFS(start, finish) {
        const visited = [], openSet = [start]; start.distance = heuristic(start, finish);
        updateNodeText(start);
        while(openSet.length){
            openSet.sort((a,b) => a.distance - b.distance);
            const current = openSet.shift();
            if(current.isWall || current.isVisited) continue;
            current.isVisited = true; visited.push(current);
            if(current === finish) return visited;
            const neighbors = getNeighbors(current);
            for(const neighbor of neighbors) if(!neighbor.isVisited){
                neighbor.distance = heuristic(neighbor, finish);
                neighbor.previousNode = current;
                updateNodeText(neighbor);
                openSet.push(neighbor);
            }
        }
        return visited;
    }
    
    function bfs(start, finish) {
        const visited = [], queue = [start]; start.isVisited = true;
        while (queue.length) {
            const current = queue.shift(); visited.push(current);
            if (current === finish) return visited;
            const neighbors = getNeighbors(current);
            for (const neighbor of neighbors) if (!neighbor.isVisited) {
                neighbor.isVisited = true; neighbor.previousNode = current;
                queue.push(neighbor);
            }
        }
        return visited;
    }
    
    function dfs(start, finish) {
        const visited = [], stack = [start];
        while(stack.length) {
            const current = stack.pop();
            if(current.isWall || current.isVisited) continue;
            current.isVisited = true; visited.push(current);
            if (current === finish) return visited;
            const neighbors = getNeighbors(current);
            for(const neighbor of neighbors) if(!neighbor.isVisited) {
                neighbor.previousNode = current; stack.push(neighbor);
            }
        }
        return visited;
    }

    async function visualizeBidirectional(start, finish) {
        const qS = [start], qF = [finish];
        const visited = []; start.isVisited = true; finish.isVisitedB = true;
        let meetingNode = null;
        while (qS.length && qF.length) {
            const nodeS = qS.shift(); visited.push({node: nodeS, from: 'start'});
            if (nodeS.isVisitedB) { meetingNode = nodeS; break; }
            const neighborsS = getNeighbors(nodeS);
            for (const neighbor of neighborsS) if (!neighbor.isVisited) {
                neighbor.isVisited = true; neighbor.previousNode = nodeS; qS.push(neighbor);
            }
            const nodeF = qF.shift(); visited.push({node: nodeF, from: 'finish'});
            if (nodeF.isVisited) { meetingNode = nodeF; break; }
            const neighborsF = getNeighbors(nodeF);
            for (const neighbor of neighborsF) if (!neighbor.isVisitedB) {
                neighbor.isVisitedB = true; neighbor.previousNodeB = nodeF; qF.push(neighbor);
            }
        }
        let pathS = [], pathF = [];
        if (meetingNode) {
            let currS = meetingNode;
            while(currS !== null) { pathS.unshift(currS); currS = currS.previousNode; }
            let currF = meetingNode.previousNodeB;
            while(currF !== null) { pathF.push(currF); currF = currF.previousNodeB; }
        }
        await animate(visited, pathS, true, pathF);
    }
    
    window.addEventListener('pathfinding-load', () => { initializeGrid(); setAlgoInfo(); });
})();


// ===============================
// ===== SORTING SCRIPT PART =====
// ===============================
(function() {
    const container = document.getElementById('sorting-visualization-container');
    const generateBtn = document.getElementById('generate-array-btn');
    const sortBtn = document.getElementById('sort-btn');
    const algoSelect = document.getElementById('algorithm-select');
    const sizeSlider = document.getElementById('array-size-slider');
    const speedSlider = document.getElementById('speed-slider');
    const sizeLabel = document.getElementById('array-size-label');

    let array = [], arraySize = 50, speed = 155;
    
    function setControls(enabled) {
        generateBtn.disabled = !enabled; sortBtn.disabled = !enabled;
        sizeSlider.disabled = !enabled;
        document.querySelectorAll('.custom-select-trigger').forEach(s => {
            enabled ? s.classList.remove('disabled') : s.classList.add('disabled');
        });
    }

    function sleep() { return new Promise(resolve => setTimeout(resolve, speed)); }

    function generateNewArray() {
        array = [];
        for (let i = 0; i < arraySize; i++) {
            array.push(Math.floor(Math.random() * (container.clientHeight * 0.9 - 20)) + 10);
        }
        renderBars(array);
    }

    function renderBars(arr, colors = {}) {
        container.innerHTML = '';
        const barWidth = Math.max(1, Math.floor(container.clientWidth / (arr.length * 1.5)));
        for (let i = 0; i < arr.length; i++) {
            const barContainer = document.createElement('div');
            barContainer.className = 'bar-container';
            const bar = document.createElement('div');
            bar.className = 'bar';
            bar.style.height = `${arr[i]}px`;
            bar.style.width = `${barWidth}px`;
            bar.style.backgroundColor = colors[i] ? `var(${colors[i]})` : 'var(--bar-default-color)';
            barContainer.appendChild(bar);
            if (arraySize <= 50) {
                const label = document.createElement('span');
                label.className = 'bar-label';
                label.textContent = arr[i];
                barContainer.appendChild(label);
            }
            container.appendChild(barContainer);
        }
    }
    
    async function startSort() {
        setControls(false);
        const algo = algoSelect.value;
        switch (algo) {
            case 'bubbleSort': await bubbleSort(); break;
            case 'selectionSort': await selectionSort(); break;
            case 'insertionSort': await insertionSort(); break;
            case 'mergeSort': await mergeSortWrapper(); break;
            case 'quickSort': await quickSortWrapper(); break;
            case 'heapSort': await heapSort(); break;
            case 'shellSort': await shellSort(); break;
            case 'radixSort': await radixSort(); break;
        }
        for (let i = 0; i < array.length; i++) {
            renderBars(array, { [i]: '--bar-sorted-color' });
            await new Promise(r => setTimeout(r, 5));
        }
        const finalColors = {};
        for(let i=0; i<array.length; i++) finalColors[i] = '--bar-sorted-color';
        renderBars(array, finalColors);
        setControls(true);
    }
    
    async function bubbleSort() {
        for (let i = 0; i < array.length - 1; i++) {
            for (let j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    [array[j], array[j + 1]] = [array[j + 1], array[j]];
                    renderBars(array, { [j]: '--bar-swap-color', [j + 1]: '--bar-swap-color' });
                    await sleep();
                } else {
                    renderBars(array, { [j]: '--bar-compare-color', [j + 1]: '--bar-compare-color' });
                    await sleep();
                }
            }
        }
    }

    async function selectionSort() {
        for (let i = 0; i < array.length - 1; i++) {
            let minIdx = i;
            for (let j = i + 1; j < array.length; j++) {
                renderBars(array, { [i]: '--bar-pivot-color', [j]: '--bar-compare-color', [minIdx]: '--bar-swap-color' });
                await sleep();
                if (array[j] < array[minIdx]) {
                    minIdx = j;
                }
            }
            [array[i], array[minIdx]] = [array[minIdx], array[i]];
        }
    }

    async function insertionSort() {
        for (let i = 1; i < array.length; i++) {
            let key = array[i], j = i - 1;
            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                renderBars(array, { [j]: '--bar-compare-color', [j + 1]: '--bar-swap-color' });
                await sleep();
                j = j - 1;
            }
            array[j + 1] = key;
        }
    }
    
    async function mergeSortWrapper() { await mergeSort(0, array.length - 1); }
    async function mergeSort(l, r) {
        if (l >= r) return;
        const m = l + Math.floor((r - l) / 2);
        await mergeSort(l, m);
        await mergeSort(m + 1, r);
        await merge(l, m, r);
    }
    async function merge(l, m, r) {
        let n1 = m - l + 1, n2 = r - m;
        let L = new Array(n1), R = new Array(n2);
        for (let i = 0; i < n1; i++) L[i] = array[l + i];
        for (let j = 0; j < n2; j++) R[j] = array[m + 1 + j];
        let i = 0, j = 0, k = l;
        while (i < n1 && j < n2) {
            renderBars(array, { [l+i]: '--bar-compare-color', [m+1+j]: '--bar-compare-color' });
            await sleep();
            if (L[i] <= R[j]) { array[k] = L[i]; i++; } 
            else { array[k] = R[j]; j++; }
            k++;
        }
        while (i < n1) { array[k] = L[i]; i++; k++; }
        while (j < n2) { array[k] = R[j]; j++; k++; }
    }
    
    async function quickSortWrapper() { await quickSort(0, array.length - 1); }
    async function quickSort(low, high) {
        if (low < high) {
            let pi = await partition(low, high);
            await quickSort(low, pi - 1);
            await quickSort(pi + 1, high);
        }
    }
    async function partition(low, high) {
        let pivot = array[high], i = low - 1;
        for (let j = low; j <= high - 1; j++) {
            renderBars(array, { [j]: '--bar-compare-color', [high]: '--bar-pivot-color' });
            await sleep();
            if (array[j] < pivot) {
                i++;
                [array[i], array[j]] = [array[j], array[i]];
                renderBars(array, { [i]: '--bar-swap-color', [j]: '--bar-swap-color' });
                await sleep();
            }
        }
        [array[i + 1], array[high]] = [array[high], array[i + 1]];
        return i + 1;
    }

    async function heapSort() {
        let n = array.length;
        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) await heapify(n, i);
        for (let i = n - 1; i > 0; i--) {
            [array[0], array[i]] = [array[i], array[0]];
            renderBars(array, { [0]: '--bar-swap-color', [i]: '--bar-swap-color' });
            await sleep();
            await heapify(i, 0);
        }
    }
    async function heapify(n, i) {
        let largest = i, l = 2 * i + 1, r = 2 * i + 2;
        if (l < n && array[l] > array[largest]) largest = l;
        if (r < n && array[r] > array[largest]) largest = r;
        if (largest !== i) {
            renderBars(array, { [i]: '--bar-compare-color', [largest]: '--bar-compare-color' });
            await sleep();
            [array[i], array[largest]] = [array[largest], array[i]];
            await heapify(n, largest);
        }
    }
    
    async function shellSort() {
        let n = array.length;
        for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
            for (let i = gap; i < n; i += 1) {
                let temp = array[i], j;
                for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {
                    array[j] = array[j - gap];
                    renderBars(array, { [j]: '--bar-swap-color', [j-gap]: '--bar-compare-color' });
                    await sleep();
                }
                array[j] = temp;
            }
        }
    }

    async function radixSort() {
        const getMax = () => Math.max(...array);
        const m = getMax();
        for (let exp = 1; Math.floor(m / exp) > 0; exp *= 10) {
            await countSort(exp);
        }
    }
    async function countSort(exp) {
        let output = new Array(array.length).fill(0);
        let count = new Array(10).fill(0);
        for (let i = 0; i < array.length; i++) count[Math.floor(array[i] / exp) % 10]++;
        for (let i = 1; i < 10; i++) count[i] += count[i - 1];
        for (let i = array.length - 1; i >= 0; i--) {
            output[count[Math.floor(array[i] / exp) % 10] - 1] = array[i];
            count[Math.floor(array[i] / exp) % 10]--;
        }
        for (let i = 0; i < array.length; i++) {
            array[i] = output[i];
            renderBars(array, { [i]: '--bar-swap-color' });
            await sleep();
        }
    }


    sizeSlider.addEventListener('input', e => { arraySize = parseInt(e.target.value); sizeLabel.textContent = arraySize; generateNewArray(); });
    speedSlider.addEventListener('input', e => { speed = 205 - parseInt(e.target.value); });
    generateBtn.addEventListener('click', generateNewArray);
    sortBtn.addEventListener('click', startSort);
    
    window.addEventListener('sorting-load', generateNewArray);
})();
</script>
</body>
</html>

