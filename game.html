<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hệ Mặt Trời Va Chạm (Siêu Chống Chịu)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --fade-duration: 0.7s;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Exo 2', sans-serif;
            color: white;
            background: #00000c;
            background: radial-gradient(ellipse at center, #00000c 0%, #000000 100%);
        }

        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            background: transparent;
        }

        canvas {
            position: relative;
            z-index: 10;
            display: block;
            background: transparent;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity var(--fade-duration) ease-in-out;
            background-color: #000;
            z-index: 100;
            opacity: 1;
            visibility: visible;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loading-text {
            font-size: 5rem;
            font-weight: 700;
            letter-spacing: 0.5rem;
            text-transform: uppercase;
            animation: flicker 2.5s infinite alternate ease-in-out;
        }
        
        @keyframes flicker {
            0%, 100% {
                text-shadow:
                0 0 5px #fff, 0 0 12px #fff, 0 0 20px #fff,
                0 0 40px #0077ff, 0 0 70px #0077ff, 0 0 80px #0077ff,
                0 0 100px #0077ff, 0 0 150px #0077ff;
            }
            50% {        
                text-shadow:
                0 0 2px #fff, 0 0 5px #fff, 0 0 10px #fff,
                0 0 20px #0077ff, 0 0 35px #0077ff, 0 0 40px #0077ff,
                0 0 50px #0077ff, 0 0 75px #0077ff;
            }
        }

        .main-content {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--fade-duration) ease-in-out;
        }
        
        .main-content.visible {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>
<body>

    <div id="loadingScreen" class="loading-screen">
        <div class="loading-text">Zero</div>
    </div>

    <div id="star-container"></div>

    <div id="mainContent" class="main-content">
        <canvas id="solarSystemCanvas"></canvas>
    </div>

    <script>
        function createStars() {
            const container = document.getElementById('star-container');
            const starCounts = [700, 200, 100];
            const starSizes = ['1px', '2px', '3px'];

            starCounts.forEach((count, i) => {
                let boxShadow = '';
                for (let j = 0; j < count; j++) {
                    boxShadow += `${Math.random() * 100}vw ${Math.random() * 100}vh #FFF${j === count - 1 ? '' : ','}`;
                }
                const starsDiv = document.createElement('div');
                starsDiv.className = 'stars';
                starsDiv.style.width = starSizes[i];
                starsDiv.style.height = starSizes[i];
                starsDiv.style.boxShadow = boxShadow;
                container.appendChild(starsDiv);
            });
        }
        createStars();

        window.addEventListener('load', () => {
            const loadingScreen = document.getElementById('loadingScreen');
            const mainContent = document.getElementById('mainContent');

            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                mainContent.classList.add('visible');
                setTimeout(init, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration')) * 1000);
            }, 1000);
        });

        function init() {
            const canvas = document.getElementById('solarSystemCanvas');
            const ctx = canvas.getContext('2d');
            let planets = [];
            let particles = [];
            
            let draggedPlanet = null;
            let lastMouseX = 0, lastMouseY = 0;
            let mouseVelX = 0, mouseVelY = 0;

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const sun = planets.find(p => p.isStatic);
                if (sun) {
                    sun.x = canvas.width / 2;
                    sun.y = canvas.height / 2;
                }
            }
            window.addEventListener('resize', resizeCanvas);
            
            class Particle {
                constructor(x, y, color, force) {
                    this.x = x; this.y = y;
                    this.radius = Math.random() * 2 + 1;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * force;
                    this.dx = Math.cos(angle) * speed;
                    this.dy = Math.sin(angle) * speed;
                    this.lifespan = 100;
                    this.color = Array.isArray(color) ? color[0] : color;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, this.lifespan / 100);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.restore();
                }
                update() {
                    this.x += this.dx; this.y += this.dy;
                    this.dx *= 0.98; this.dy *= 0.98;
                    this.lifespan--;
                }
            }

            function createExplosion(x, y, color, force, count) {
                for (let i = 0; i < count; i++) {
                    particles.push(new Particle(x, y, color, force));
                }
            }
            
            class Planet {
                constructor(name, radius, color, speed, detailsDrawer = () => {}, isStatic = false) {
                    this.name = name;
                    this.initialRadius = radius; this.radius = radius;
                    this.color = color;
                    this.isStatic = isStatic;

                    if (this.isStatic) {
                        this.x = window.innerWidth / 2;
                        this.y = window.innerHeight / 2;
                    } else {
                        this.x = Math.random() * (canvas.width - 2 * radius) + radius;
                        this.y = Math.random() * (canvas.height - 2 * radius) + radius;
                    }

                    this.dx = this.isStatic ? 0 : (Math.random() - 0.5) * speed;
                    this.dy = this.isStatic ? 0 : (Math.random() - 0.5) * speed;
                    this.mass = this.isStatic ? 1e10 : Math.PI * radius * radius;
                    this.detailsDrawer = detailsDrawer;
                    this.isDragging = false;
                    this.health = 100;
                    this.isDestroyed = false;
                }

                draw() {
                    ctx.save();
                    this.detailsDrawer(ctx, this.x, this.y, this.radius);
                    
                    const gradient = ctx.createRadialGradient(
                        this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.1, 
                        this.x, this.y, this.radius
                    );
                    const baseColor = Array.isArray(this.color) ? this.color[0] : this.color;
                    const highlightColor = Array.isArray(this.color) ? this.color[1] : 'white';
                    gradient.addColorStop(0, highlightColor);
                    gradient.addColorStop(1, baseColor);
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    ctx.closePath();
                    
                    ctx.restore();

                    if (!this.isStatic) {
                         ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                         ctx.font = `${Math.max(12, this.initialRadius / 3)}px 'Exo 2'`;
                         ctx.textAlign = 'center';
                         ctx.fillText(this.name, this.x, this.y + this.initialRadius + 20);
                    }
                }

                takeDamage(force) {
                    if (this.isStatic || force < 1) return;
                    
                    // Giảm mạnh hệ số sát thương để tăng sức chống chịu
                    this.health -= force * 0.05; 
                    
                    if (this.health <= 0) {
                        this.health = 0; this.isDestroyed = true;
                    }
                    this.radius = this.initialRadius * (this.health / 100);
                }

                update() {
                    if (this.isStatic || this.isDragging) return;
                    if (this.x + this.radius > canvas.width) {
                        this.x = canvas.width - this.radius;
                        this.dx = -this.dx * 0.9;
                    } else if (this.x - this.radius < 0) {
                        this.x = this.radius;
                        this.dx = -this.dx * 0.9;
                    }
                    if (this.y + this.radius > canvas.height) {
                        this.y = canvas.height - this.radius;
                        this.dy = -this.dy * 0.9;
                    } else if (this.y - this.radius < 0) {
                        this.y = this.radius;
                        this.dy = -this.dy * 0.9;
                    }
                    this.x += this.dx; this.y += this.dy;
                }
            }
            
            const drawSaturnDetails = (ctx, x, y, radius) => {
                if (radius < 5) return;
                ctx.strokeStyle = 'rgba(210, 180, 140, 0.7)';
                ctx.lineWidth = Math.max(1, radius * 0.1);
                ctx.beginPath();
                ctx.ellipse(x, y, radius * 1.6, radius * 0.5, 0.2, 0, Math.PI * 2);
                ctx.stroke();
            };
            const drawSunDetails = (ctx, x, y, radius) => {
                ctx.shadowBlur = radius * 0.5;
                ctx.shadowColor = "rgba(255, 255, 100, 0.5)";
            };
            
            planets = [
                new Planet('Mặt Trời', 100, ['#ff4500', '#ffff00'], 0, drawSunDetails, true),
                new Planet('Mặt Trăng', 15, ['#cccccc', '#f5f5f5'], 3.5),
                new Planet('Sao Thủy', 20, ['#8c8c8c', '#e6e6e6'], 2.5),
                new Planet('Sao Kim', 35, ['#d4a162', '#fff0d9'], 2),
                new Planet('Trái Đất', 40, ['#2f6a69', '#87ceeb'], 1.8),
                new Planet('Sao Hỏa', 30, ['#a52a2a', '#e57373'], 2.2),
                new Planet('Sao Mộc', 80, ['#bcaea1', '#e0d8d0'], 1),
                new Planet('Sao Thổ', 70, ['#d2b48c', '#f5e8d0'], 1.2, drawSaturnDetails),
                new Planet('Sao Thiên Vương', 55, ['#b0e0e6', '#e0ffff'], 1.5),
                new Planet('Sao Hải Vương', 50, ['#3f51b5', '#8c9eff'], 1.6)
            ];

            resizeCanvas();

            canvas.addEventListener('mousedown', e => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                for (let i = planets.length - 1; i >= 0; i--) {
                    const p = planets[i];
                    if (p.isStatic) continue;
                    const dist = Math.sqrt((mouseX - p.x)**2 + (mouseY - p.y)**2);
                    if (dist < p.radius) {
                        draggedPlanet = p;
                        p.isDragging = true;
                        p.dx = 0; p.dy = 0;
                        lastMouseX = mouseX;
                        lastMouseY = mouseY;
                        break;
                    }
                }
            });

            canvas.addEventListener('mousemove', e => {
                if (draggedPlanet) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    mouseVelX = mouseX - lastMouseX;
                    mouseVelY = mouseY - lastMouseY;
                    draggedPlanet.x = mouseX;
                    draggedPlanet.y = mouseY;
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                }
            });

            canvas.addEventListener('mouseup', () => {
                if (draggedPlanet) {
                    draggedPlanet.isDragging = false;
                    draggedPlanet.dx = mouseVelX;
                    draggedPlanet.dy = mouseVelY;
                    draggedPlanet = null;
                }
            });
            
            function handleCollisions() {
                for (let i = 0; i < planets.length; i++) {
                    for (let j = i + 1; j < planets.length; j++) {
                        const p1 = planets[i], p2 = planets[j];
                        const dX = p2.x - p1.x, dY = p2.y - p1.y;
                        const distance = Math.sqrt(dX * dX + dY * dY);

                        if (distance < p1.radius + p2.radius && distance > 0) {
                            const angle = Math.atan2(dY, dX), sin = Math.sin(angle), cos = Math.cos(angle);
                            let v1 = { x: p1.dx * cos + p1.dy * sin, y: p1.dy * cos - p1.dx * sin };
                            let v2 = { x: p2.dx * cos + p2.dy * sin, y: p2.dy * cos - p2.dx * sin };
                            const impactForce = Math.abs(v1.x - v2.x);
                            let vFinal1 = ((p1.mass - p2.mass) * v1.x + 2 * p2.mass * v2.x) / (p1.mass + p2.mass);
                            let vFinal2 = ((p2.mass - p1.mass) * v2.x + 2 * p1.mass * v1.x) / (p1.mass + p2.mass);
                            
                            v1.x = vFinal1; v2.x = vFinal2;
                            
                            if(!p1.isStatic) { p1.dx = v1.x * cos - v1.y * sin; p1.dy = v1.y * cos + v1.x * sin; }
                            if(!p2.isStatic) { p2.dx = v2.x * cos - v2.y * sin; p2.dy = v2.y * cos + v2.x * sin; }
                            
                            const impactX = (p1.x * p2.radius + p2.x * p1.radius) / (p1.radius + p2.radius);
                            const impactY = (p1.y * p2.radius + p2.y * p1.radius) / (p1.radius + p2.radius);
                            createExplosion(impactX, impactY, p1.color, impactForce, Math.min(20, Math.ceil(impactForce)));
                            p1.takeDamage(impactForce); p2.takeDamage(impactForce);

                            const overlap = (p1.radius + p2.radius - distance);
                            if (p1.isStatic) {
                                p2.x += overlap * cos;
                                p2.y += overlap * sin;
                            } else if (p2.isStatic) {
                                p1.x -= overlap * cos;
                                p1.y -= overlap * sin;
                            } else {
                                p1.x -= (overlap / 2) * cos;
                                p1.y -= (overlap / 2) * sin;
                                p2.x += (overlap / 2) * cos;
                                p2.y += (overlap / 2) * sin;
                            }
                        }
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                particles.forEach((p, index) => {
                    if (p.lifespan <= 0) particles.splice(index, 1);
                    else { p.update(); p.draw(); }
                });
                
                planets.forEach(p => { p.update(); p.draw(); });
                
                handleCollisions();

                const survivingPlanets = [];
                for(const planet of planets) {
                    if (planet.isDestroyed) {
                        createExplosion(planet.x, planet.y, planet.color, planet.initialRadius / 4, planet.initialRadius * 2);
                    } else {
                        survivingPlanets.push(planet);
                    }
                }
                planets = survivingPlanets;
            }
            animate();
        }
    </script>
</body>
</html>
